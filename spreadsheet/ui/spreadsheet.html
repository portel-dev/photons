<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="mcp:ui-size" content="minWidth=800;minHeight=400;maxHeight=900">
    <title>Spreadsheet</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Default: dark theme */
        :root {
            --primary: #2ea043;
            --primary-hover: #3fb950;
            --bg-primary: #0d1117;
            --bg-secondary: #161b22;
            --bg-tertiary: #21262d;
            --border: #30363d;
            --border-dark: #484f58;
            --text-primary: #c9d1d9;
            --text-secondary: #8b949e;
            --text-muted: #6e7681;
            --accent: #58a6ff;
            --error: #f85149;
            --formula-bar-bg: #161b22;
            --header-bg: #161b22;
            --grid-line: #30363d;
            --selection: #58a6ff;
            --selection-bg: rgba(88, 166, 255, 0.15);
            --cell-active: #0d1117;
            --cell-empty: rgba(255, 255, 255, 0.03);
            --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.3);
            --shadow-md: 0 3px 6px rgba(0, 0, 0, 0.4);
        }

        /* Light theme override via .light class on :root */
        :root.light {
            --primary: #217346;
            --primary-hover: #1e623c;
            --bg-primary: #ffffff;
            --bg-secondary: #f8f9fa;
            --bg-tertiary: #f3f2f1;
            --border: #e1e4e8;
            --border-dark: #d0d7de;
            --text-primary: #24292f;
            --text-secondary: #57606a;
            --text-muted: #8c959f;
            --accent: #0969da;
            --error: #cf222e;
            --formula-bar-bg: #f6f8fa;
            --header-bg: #f6f8fa;
            --grid-line: #d0d7de;
            --selection: #0969da;
            --selection-bg: rgba(9, 105, 218, 0.1);
            --cell-active: #ffffff;
            --cell-empty: rgba(0, 0, 0, 0.03);
            --shadow-sm: 0 1px 2px rgba(31, 35, 40, 0.04);
            --shadow-md: 0 3px 6px rgba(31, 35, 40, 0.08);
        }

        /* Slim scrollbars */
        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }
        ::-webkit-scrollbar-track {
            background: transparent;
        }
        ::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 3px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: var(--border-dark);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Noto Sans', Helvetica, Arial, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            transition: background 0.2s, color 0.2s;
        }

        /* Toolbar */
        .toolbar {
            background: var(--bg-primary);
            border-bottom: 1px solid var(--border);
            padding: 8px 16px;
            display: flex;
            align-items: center;
            gap: 12px;
            box-shadow: var(--shadow-sm);
            z-index: 100;
        }

        .toolbar-section {
            display: flex;
            align-items: center;
            gap: 6px;
            padding-right: 12px;
            border-right: 1px solid var(--border);
        }

        .toolbar-section:last-child {
            border-right: none;
            padding-right: 0;
        }

        .btn {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 6px 12px;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.15s;
            color: var(--text-primary);
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .btn:hover {
            background: var(--bg-tertiary);
            border-color: var(--border-dark);
        }

        .btn-primary {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        .btn-primary:hover {
            background: var(--primary-hover);
            border-color: var(--primary-hover);
        }

        .btn-icon {
            padding: 6px 8px;
            font-size: 14px;
        }

        .btn.active {
            background: var(--selection-bg);
            border-color: var(--selection);
            color: var(--selection);
        }

        /* Source view toggle */
        .btn-source-toggle {
            font-family: 'SF Mono', 'Fira Code', 'Cascadia Code', monospace;
            font-size: 13px;
            font-weight: 600;
            letter-spacing: -0.5px;
        }

        .btn-source-toggle.active {
            background: var(--accent);
            color: white;
            border-color: var(--accent);
        }

        /* Source view cell styling */
        .source-view td .cell-content {
            font-family: 'SF Mono', 'Fira Code', 'Cascadia Code', monospace;
            font-size: 12px;
            opacity: 0.85;
            color: var(--accent);
        }

        .source-view td.cell-formula .cell-content {
            color: var(--primary);
            opacity: 1;
        }

        /* Chart overlay styles */
        .chart-overlay {
            position: absolute;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 8px;
            box-shadow: var(--shadow-md);
            z-index: 50;
            min-width: 200px;
            min-height: 150px;
            overflow: hidden;
        }

        .chart-overlay .chart-titlebar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 4px 8px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
            cursor: move;
            font-size: 11px;
            color: var(--text-secondary);
            user-select: none;
        }

        .chart-overlay .chart-titlebar .chart-type-label {
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .chart-overlay .chart-close {
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            font-size: 14px;
            padding: 0 4px;
            line-height: 1;
        }

        .chart-overlay .chart-close:hover {
            color: var(--error);
        }

        .chart-overlay .chart-body {
            padding: 8px;
            position: relative;
        }

        .chart-overlay .chart-resize {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 12px;
            height: 12px;
            cursor: nwse-resize;
            opacity: 0.3;
        }

        .chart-overlay .chart-resize:hover {
            opacity: 0.6;
        }

        .chart-overlay .chart-resize::after {
            content: '';
            position: absolute;
            bottom: 3px;
            right: 3px;
            width: 6px;
            height: 6px;
            border-right: 2px solid var(--text-muted);
            border-bottom: 2px solid var(--text-muted);
        }

        /* Chart anchor cell indicator */
        td.chart-anchor .cell-content::before {
            content: attr(data-chart-icon);
            margin-right: 4px;
        }

        /* Sparkline cell */
        td .sparkline-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
        }

        td .sparkline-container svg {
            width: 100%;
            height: 24px;
        }

        .theme-toggle {
            background: transparent;
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 6px 10px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.15s;
        }

        .theme-toggle:hover {
            background: var(--bg-tertiary);
        }

        /* View Controls */
        .view-controls {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .view-btn {
            background: transparent;
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 4px 12px;
            font-size: 12px;
            cursor: pointer;
            color: var(--text-secondary);
            transition: all 0.15s;
        }

        .view-btn:hover {
            background: var(--bg-tertiary);
        }

        .view-btn.active {
            background: var(--selection);
            color: white;
            border-color: var(--selection);
        }

        /* Formula Bar */
        .formula-container {
            background: var(--formula-bar-bg);
            border-bottom: 1px solid var(--border);
            padding: 8px 16px;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .cell-reference {
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 6px 10px;
            font-size: 13px;
            font-weight: 600;
            color: var(--text-primary);
            min-width: 80px;
            text-align: center;
            font-family: 'SF Mono', Monaco, monospace;
        }

        .formula-input-wrapper {
            flex: 1;
            display: flex;
            align-items: center;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 0 12px;
            transition: border-color 0.15s;
        }

        .formula-input-wrapper:focus-within {
            border-color: var(--accent);
            box-shadow: 0 0 0 3px var(--selection-bg);
        }

        .formula-input-wrapper {
            position: relative;
        }

        /* Formula Autocomplete */
        .formula-autocomplete {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-top: none;
            border-radius: 0 0 6px 6px;
            box-shadow: var(--shadow-md);
            z-index: 200;
            max-height: 220px;
            overflow-y: auto;
            display: none;
        }

        .formula-autocomplete.visible {
            display: block;
        }

        .formula-autocomplete-item {
            padding: 6px 12px;
            cursor: pointer;
            display: flex;
            align-items: baseline;
            gap: 8px;
            font-size: 13px;
            border-bottom: 1px solid var(--border);
        }

        .formula-autocomplete-item:last-child {
            border-bottom: none;
        }

        .formula-autocomplete-item:hover,
        .formula-autocomplete-item.active {
            background: var(--selection-bg);
        }

        .fn-name {
            font-family: 'SF Mono', Monaco, monospace;
            font-weight: 600;
            color: var(--primary);
            min-width: 60px;
        }

        .fn-syntax {
            font-family: 'SF Mono', Monaco, monospace;
            color: var(--text-secondary);
            font-size: 12px;
        }

        .fn-desc {
            color: var(--text-muted);
            font-size: 11px;
            margin-left: auto;
        }

        /* Argument Hint */
        .formula-arg-hint {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-top: none;
            border-radius: 0 0 6px 6px;
            box-shadow: var(--shadow-sm);
            z-index: 199;
            padding: 6px 12px;
            font-size: 12px;
            display: none;
        }

        .formula-arg-hint.visible {
            display: block;
        }

        .formula-arg-hint .hint-fn {
            font-family: 'SF Mono', Monaco, monospace;
            font-weight: 600;
            color: var(--primary);
        }

        .formula-arg-hint .hint-sep {
            color: var(--text-muted);
            margin: 0 6px;
        }

        .formula-arg-hint .hint-desc {
            color: var(--text-secondary);
        }

        /* Formula Error Hint */
        .formula-error-hint {
            background: color-mix(in srgb, var(--error) 8%, transparent);
            border: 1px solid color-mix(in srgb, var(--error) 25%, transparent);
            border-top: none;
            padding: 4px 12px;
            font-size: 12px;
            color: var(--error);
            display: none;
        }

        .formula-error-hint.visible {
            display: block;
        }

        /* Context Menu */
        .context-menu {
            position: fixed;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 8px;
            box-shadow: var(--shadow-md);
            z-index: 300;
            min-width: 180px;
            padding: 4px 0;
            display: none;
        }

        .context-menu.visible {
            display: block;
        }

        .context-menu-item {
            padding: 8px 16px;
            cursor: pointer;
            font-size: 13px;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .context-menu-item:hover {
            background: var(--selection-bg);
        }

        .context-menu-sep {
            height: 1px;
            background: var(--border);
            margin: 4px 0;
        }

        .formula-indicator {
            color: var(--primary);
            font-size: 16px;
            margin-right: 8px;
            display: none;
            user-select: none;
        }

        .formula-input-wrapper.has-formula .formula-indicator {
            display: inline;
        }

        #formulaInput {
            flex: 1;
            border: none;
            outline: none;
            padding: 6px 0;
            font-size: 14px;
            font-family: 'SF Mono', Monaco, monospace;
            background: transparent;
            color: var(--text-primary);
        }

        /* Field Type Selector */
        .field-type-selector {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 0 12px;
            border-left: 1px solid var(--border);
            margin-left: 8px;
        }

        .field-type-label {
            font-size: 12px;
            color: var(--text-secondary);
        }

        .field-type-dropdown {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 12px;
            cursor: pointer;
            color: var(--text-primary);
        }

        /* Main Content */
        .main-content {
            flex: 1;
            display: flex;
            overflow: hidden;
            min-height: 0;
        }

        /* Sidebar for Views */
        .sidebar {
            width: 240px;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            transition: width 0.2s;
        }

        .sidebar.collapsed {
            width: 0;
            overflow: hidden;
        }

        .sidebar-header {
            padding: 12px 16px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .sidebar-title {
            font-size: 13px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .sidebar-section {
            padding: 12px;
            border-bottom: 1px solid var(--border);
        }

        .sidebar-section-title {
            font-size: 11px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
        }

        .view-list {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .view-item {
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.15s;
        }

        .view-item:hover {
            background: var(--bg-tertiary);
        }

        .view-item.active {
            background: var(--selection-bg);
            color: var(--selection);
            font-weight: 500;
        }

        .filter-group {
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 8px;
            margin-bottom: 8px;
        }

        .filter-group-header {
            font-size: 12px;
            font-weight: 600;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .filter-condition {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
            align-items: center;
        }

        .filter-select {
            flex: 1;
            padding: 4px 8px;
            border: 1px solid var(--border);
            border-radius: 4px;
            background: var(--bg-secondary);
            color: var(--text-primary);
            font-size: 12px;
        }

        /* Sheet Container */
        .sheet-container {
            flex: 1;
            overflow: auto;
            position: relative;
            background: var(--bg-secondary);
        }

        /* Grid */
        .grid-wrapper {
            position: relative;
            min-width: fit-content;
            min-height: fit-content;
            background: var(--bg-primary);
        }

        table {
            border-collapse: separate;
            border-spacing: 0;
            font-size: 13px;
            table-layout: fixed;
        }

        th, td {
            border-right: 1px solid var(--grid-line);
            border-bottom: 1px solid var(--grid-line);
            padding: 0;
            position: relative;
        }

        /* Headers */
        th {
            background: var(--header-bg);
            font-weight: 600;
            color: var(--text-secondary);
            text-align: center;
            position: sticky;
            z-index: 10;
        }

        th.corner {
            position: sticky;
            top: 0;
            left: 0;
            z-index: 20;
            width: 50px;
            height: 25px;
            background: var(--header-bg);
            border-right: 1px solid var(--border-dark);
            border-bottom: 1px solid var(--border-dark);
            cursor: pointer;
        }

        th.corner:hover {
            background: var(--bg-tertiary);
        }

        th.col-header {
            top: 0;
            height: 25px;
            min-width: 100px;
            border-bottom: 1px solid var(--border-dark);
        }

        th.row-header {
            left: 0;
            width: 50px;
            height: 24px;
            border-right: 1px solid var(--border-dark);
        }

        th.col-header:hover, th.row-header:hover {
            background: var(--bg-tertiary);
            cursor: pointer;
        }

        th.selected, td.selected {
            background: var(--selection-bg);
            outline: 2px solid var(--selection);
            outline-offset: -2px;
        }

        /* Cells */
        td {
            background: var(--bg-primary);
            height: 24px;
            min-width: 100px;
            max-width: 300px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        td:hover {
            background: var(--bg-secondary);
        }

        td.selected {
            background: var(--bg-primary);
        }

        td.empty {
            background: var(--cell-empty);
        }

        td.empty:hover {
            background: var(--cell-empty);
            opacity: 0.8;
        }

        .cell-content {
            padding: 0 6px;
            height: 100%;
            display: flex;
            align-items: center;
            overflow: hidden;
            text-overflow: ellipsis;
            color: var(--text-primary);
        }

        td.empty .cell-content {
            color: var(--text-muted);
            font-style: italic;
        }

        .cell-number {
            text-align: right;
            justify-content: flex-end;
        }

        .cell-error {
            color: var(--error);
        }

        /* Cell Types */
        .cell-checkbox {
            justify-content: center;
        }

        .cell-checkbox input[type="checkbox"] {
            cursor: pointer;
        }

        .cell-link {
            color: var(--accent);
            text-decoration: underline;
            cursor: pointer;
        }

        .cell-select {
            background: var(--bg-tertiary);
            border-radius: 4px;
            padding: 2px 8px;
            font-size: 11px;
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }

        .cell-attachment {
            display: flex;
            gap: 4px;
            align-items: center;
        }

        .attachment-badge {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 2px 6px;
            font-size: 11px;
        }

        /* Grouped Rows */
        .group-header {
            background: var(--bg-tertiary) !important;
            font-weight: 600;
            cursor: pointer;
        }

        .group-header td {
            background: var(--bg-tertiary);
            border-bottom: 2px solid var(--border-dark);
        }

        .group-toggle {
            margin-right: 8px;
            font-size: 10px;
        }

        .grouped-row {
            display: table-row;
        }

        .grouped-row.collapsed {
            display: none;
        }

        /* Status Bar */
        .status-bar {
            background: var(--bg-secondary);
            border-top: 1px solid var(--border);
            padding: 6px 16px;
            font-size: 12px;
            color: var(--text-secondary);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .status-left {
            display: flex;
            gap: 16px;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        /* Resize handles */
        .resize-handle {
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            width: 4px;
            cursor: col-resize;
            z-index: 5;
        }

        .resize-handle:hover {
            background: var(--accent);
        }

        /* CSV Import/Export Modal */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal {
            background: var(--bg-primary);
            border-radius: 12px;
            box-shadow: var(--shadow-md);
            width: 90%;
            max-width: 600px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            border: 1px solid var(--border);
        }

        .modal-header {
            padding: 16px 20px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-title {
            font-size: 16px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            color: var(--text-secondary);
            padding: 4px;
            line-height: 1;
        }

        .modal-body {
            padding: 20px;
            flex: 1;
            overflow: auto;
        }

        .modal-footer {
            padding: 16px 20px;
            border-top: 1px solid var(--border);
            display: flex;
            justify-content: flex-end;
            gap: 8px;
        }

        textarea.csv-input {
            width: 100%;
            height: 300px;
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 12px;
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 13px;
            resize: vertical;
            background: var(--bg-secondary);
            color: var(--text-primary);
        }

        /* Helper text */
        .formula-help {
            font-size: 12px;
            color: var(--text-secondary);
            margin-top: 8px;
            line-height: 1.5;
        }

        .formula-help code {
            background: var(--bg-tertiary);
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'SF Mono', Monaco, monospace;
            color: var(--text-primary);
        }

        /* Linked Record Modal */
        .linked-record-modal {
            max-width: 800px;
        }

        .record-list {
            max-height: 400px;
            overflow: auto;
            border: 1px solid var(--border);
            border-radius: 6px;
        }

        .record-item {
            padding: 12px;
            border-bottom: 1px solid var(--border);
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 12px;
            transition: background 0.15s;
        }

        .record-item:hover {
            background: var(--bg-secondary);
        }

        .record-item.selected {
            background: var(--selection-bg);
        }

        .record-checkbox {
            width: 18px;
            height: 18px;
        }

        .record-preview {
            flex: 1;
            display: flex;
            gap: 16px;
        }

        .record-field {
            font-size: 13px;
        }

        .record-field-label {
            font-size: 11px;
            color: var(--text-secondary);
            margin-bottom: 2px;
        }

        /* Toggle sidebar button */
        .sidebar-toggle {
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-left: none;
            border-radius: 0 4px 4px 0;
            padding: 8px 4px;
            cursor: pointer;
            z-index: 50;
            font-size: 12px;
            color: var(--text-secondary);
        }

        .sheet-wrapper {
            position: relative;
            flex: 1;
            display: flex;
        }
    </style>
</head>
<body>
    <!-- Toolbar -->
    <div class="toolbar">
        <div class="toolbar-section">
            <button class="btn btn-primary" onclick="spreadsheet.newFile()">
                <span>+</span> New
            </button>
            <button class="btn" onclick="spreadsheet.openImportModal()">
                Import CSV
            </button>
            <button class="btn" onclick="spreadsheet.exportCSV()">
                Export CSV
            </button>
        </div>
        <div class="toolbar-section">
            <button class="btn btn-icon" onclick="spreadsheet.addRow()" title="Add Row">Add Row</button>
            <button class="btn btn-icon" onclick="spreadsheet.addColumn()" title="Add Column">Add Col</button>
            <button class="btn btn-icon" onclick="spreadsheet.deleteRow()" title="Delete Row" style="color: var(--error)">Delete Row</button>
            <button class="btn btn-icon" onclick="spreadsheet.deleteColumn()" title="Delete Column" style="color: var(--error)">Delete Col</button>
        </div>
        <div class="toolbar-section">
            <button class="btn" onclick="spreadsheet.toggleView('grid')" id="btn-grid">Grid</button>
            <button class="btn" onclick="spreadsheet.toggleView('gallery')" id="btn-gallery">Gallery</button>
            <button class="btn" onclick="spreadsheet.toggleView('kanban')" id="btn-kanban">Kanban</button>
        </div>
        <div class="toolbar-section">
            <button class="btn btn-source-toggle" onclick="spreadsheet.toggleSourceView()" id="btn-source" title="Toggle source/runtime view">&lt;/&gt;</button>
        </div>
        <!-- Theme controlled by host via onThemeChange -->
    </div>

    <!-- Formula Bar -->
    <div class="formula-container">
        <div class="cell-reference" id="cellRef">A1</div>
        <div class="formula-input-wrapper" id="formulaWrapper">
            <span class="formula-indicator">∆í</span>
            <input type="text" id="formulaInput" placeholder="Enter formula (start with =) or value..." autocomplete="off">
            <div class="formula-autocomplete" id="formulaAutocomplete"></div>
            <div class="formula-arg-hint" id="formulaArgHint"></div>
        </div>
        <div class="field-type-selector">
            <span class="field-type-label">Type:</span>
            <select class="field-type-dropdown" id="fieldType" onchange="spreadsheet.setFieldType()">
                <option value="text">Single Line Text</option>
                <option value="longtext">Long Text</option>
                <option value="number">Number</option>
                <option value="checkbox">Checkbox</option>
                <option value="select">Single Select</option>
                <option value="multiselect">Multiple Select</option>
                <option value="date">Date</option>
                <option value="attachment">Attachment</option>
                <option value="link">Linked Record</option>
                <option value="formula">Formula</option>
            </select>
        </div>
    </div>

    <div class="formula-error-hint" id="formulaErrorHint"></div>

    <!-- Context Menu -->
    <div class="context-menu" id="contextMenu">
        <div class="context-menu-item" data-action="fill">Fill range...</div>
        <div class="context-menu-item" data-action="clear">Clear cell</div>
        <div class="context-menu-sep"></div>
        <div class="context-menu-item" data-action="rename">Rename column</div>
    </div>

    <!-- Main Content -->
    <div class="main-content">
        <!-- Sidebar -->
        <div class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <span class="sidebar-title">Views & Filters</span>
                <button class="btn-icon" onclick="spreadsheet.toggleSidebar()">‚Üê</button>
            </div>
            
            <div class="sidebar-section">
                <div class="sidebar-section-title">Views</div>
                <div class="view-list" id="viewList">
                    <div class="view-item active" onclick="spreadsheet.switchView('grid')">
                        <span>‚äû</span> Grid view
                    </div>
                    <div class="view-item" onclick="spreadsheet.switchView('grouped')">
                        <span>‚ò∞</span> Grouped by Status
                    </div>
                    <div class="view-item" onclick="spreadsheet.switchView('calendar')">
                        <span>üìÖ</span> Calendar
                    </div>
                </div>
            </div>

            <div class="sidebar-section">
                <div class="sidebar-section-title">Group By</div>
                <select class="filter-select" id="groupBySelect" onchange="spreadsheet.applyGrouping()">
                    <option value="">None</option>
                </select>
            </div>

            <div class="sidebar-section">
                <div class="sidebar-section-title">Filters</div>
                <div id="filterContainer">
                    <div class="filter-group">
                        <div class="filter-condition">
                            <select class="filter-select" id="filterColumn">
                                <option value="">Select column...</option>
                            </select>
                        </div>
                        <div class="filter-condition">
                            <select class="filter-select" id="filterOperator">
                                <option value="equals">equals</option>
                                <option value="contains">contains</option>
                                <option value="greater">greater than</option>
                                <option value="less">less than</option>
                                <option value="empty">is empty</option>
                            </select>
                        </div>
                        <input type="text" class="filter-select" id="filterValue" placeholder="Value...">
                        <button class="btn btn-primary" onclick="spreadsheet.addFilter()" style="width: 100%; margin-top: 8px;">Apply Filter</button>
                    </div>
                </div>
            </div>

            <div class="sidebar-section">
                <div class="sidebar-section-title">Sort</div>
                <div class="filter-condition">
                    <select class="filter-select" id="sortColumn" onchange="spreadsheet.applySort()">
                        <option value="">Select column...</option>
                    </select>
                    <select class="filter-select" id="sortDirection" onchange="spreadsheet.applySort()">
                        <option value="asc">A ‚Üí Z</option>
                        <option value="desc">Z ‚Üí A</option>
                    </select>
                </div>
            </div>
        </div>

        <!-- Sheet -->
        <div class="sheet-wrapper">
            <button class="sidebar-toggle" onclick="spreadsheet.toggleSidebar()" id="sidebarToggle">‚ñ∂</button>
            <div class="sheet-container" id="sheetContainer">
                <div class="grid-wrapper" id="gridWrapper">
                    <table id="spreadsheet">
                        <thead id="tableHead"></thead>
                        <tbody id="tableBody"></tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <!-- Status Bar -->
    <div class="status-bar">
        <div class="status-left">
            <span class="status-item" id="cellCount">Ready</span>
            <span class="status-item" id="sumDisplay"></span>
            <span class="status-item" id="recordCount"></span>
        </div>
        <div class="status-right">
            <span class="status-item">Spreadsheet</span>
        </div>
    </div>

    <!-- Import Modal -->
    <div class="modal-overlay" id="importModal">
        <div class="modal">
            <div class="modal-header">
                <span class="modal-title">Import CSV Data</span>
                <button class="modal-close" onclick="spreadsheet.closeImportModal()">√ó</button>
            </div>
            <div class="modal-body">
                <textarea class="csv-input" id="csvInput" placeholder="Paste your CSV data here...
Example:
Name,Age,City,Status
John,30,New York,Active
Jane,25,London,Inactive"></textarea>
                <div class="formula-help">
                    <strong>Supported formulas:</strong> Start with <code>=</code> to create formulas.<br>
                    Use <code>A1</code>, <code>B2</code> notation or <code>Name1</code>, <code>Age2</code> (header + row).<br>
                    Functions: <code>SUM</code>, <code>AVG</code>, <code>MAX</code>, <code>MIN</code>, <code>COUNT</code>, <code>IF</code>, <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>^</code>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn" onclick="spreadsheet.closeImportModal()">Cancel</button>
                <button class="btn btn-primary" onclick="spreadsheet.importCSV()">Import</button>
            </div>
        </div>
    </div>

    <!-- Linked Record Modal -->
    <div class="modal-overlay" id="linkedRecordModal">
        <div class="modal linked-record-modal">
            <div class="modal-header">
                <span class="modal-title">Link Records</span>
                <button class="modal-close" onclick="spreadsheet.closeLinkedRecordModal()">√ó</button>
            </div>
            <div class="modal-body">
                <div class="record-list" id="recordList">
                    <!-- Records will be populated here -->
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn" onclick="spreadsheet.closeLinkedRecordModal()">Cancel</button>
                <button class="btn btn-primary" onclick="spreadsheet.confirmLinkRecords()">Link Selected</button>
            </div>
        </div>
    </div>

    <script>
        class SpreadsheetEngine {
            constructor(rows = 20, cols = 10) {
                this.data = [];
                this.formulas = [];
                this.headers = [];
                this.fieldTypes = []; // Store field types for each column
                this.selectOptions = []; // Options for select fields
                this.linkedRecords = []; // Store linked record relationships
                this.rowCount = rows;
                this.colCount = cols;
                this.selectedCell = { row: 0, col: 0 };
                this.isEditing = false;
                this.editStartValue = '';
                this.columnWidths = new Array(cols).fill(100);
                this.sidebarVisible = false;
                this.columnMeta = [];
                this.currentView = 'grid';
                this.groupByColumn = null;
                this.filters = [];
                this.sortConfig = { column: null, direction: 'asc' };
                this.hiddenRows = new Set();
                this.acIndex = -1; // autocomplete selected index
                this.acItems = []; // current autocomplete matches
                this._previewTimer = null;
                this.viewMode = 'runtime'; // 'runtime' or 'source'
                this.chartOverlays = new Map(); // cell ref ‚Üí overlay element
                this.formulaCatalog = [
                    { name: 'SUM',     syntax: 'SUM(range)',              desc: 'Adds all numbers in a range' },
                    { name: 'AVG',     syntax: 'AVG(range)',              desc: 'Average of numbers in a range' },
                    { name: 'AVERAGE', syntax: 'AVERAGE(range)',          desc: 'Average (alias for AVG)' },
                    { name: 'MAX',     syntax: 'MAX(range)',              desc: 'Largest number in a range' },
                    { name: 'MIN',     syntax: 'MIN(range)',              desc: 'Smallest number in a range' },
                    { name: 'COUNT',   syntax: 'COUNT(range)',            desc: 'Count of numbers in a range' },
                    { name: 'IF',      syntax: 'IF(cond, true, false)',   desc: 'Conditional value' },
                    { name: 'LEN',     syntax: 'LEN(text)',              desc: 'Length of text' },
                    { name: 'ABS',     syntax: 'ABS(number)',            desc: 'Absolute value' },
                    { name: 'ROUND',   syntax: 'ROUND(number, digits)',  desc: 'Round to N digits' },
                    { name: 'CONCAT',  syntax: 'CONCAT(a, b, ...)',     desc: 'Join values together' },
                    { name: 'PIE',     syntax: 'PIE(labels, values)',   desc: 'Pie chart overlay' },
                    { name: 'BAR',     syntax: 'BAR(labels, values)',   desc: 'Bar chart overlay' },
                    { name: 'LINE',    syntax: 'LINE(labels, values)',  desc: 'Line chart overlay' },
                    { name: 'SPARKLINE', syntax: 'SPARKLINE(range)',    desc: 'Inline sparkline' },
                    { name: 'GAUGE',   syntax: 'GAUGE(value, min, max)', desc: 'Gauge meter overlay' },
                ];
                this.init();
            }

            init() {
                this.generateHeaders();
                this.initializeData();
                this.initializeFieldTypes();
                this.render();
                this.setupEventListeners();
                this.updateFilterOptions();
                this.selectCell(0, 0);
                // Start with sidebar collapsed
                document.getElementById('sidebar')?.classList.add('collapsed');
                const toggle = document.getElementById('sidebarToggle');
                if (toggle) toggle.textContent = '‚ñ∂';
            }

            initializeFieldTypes() {
                this.fieldTypes = new Array(this.colCount).fill('text');
                this.selectOptions = new Array(this.colCount).fill(null).map(() => []);
                this.linkedRecords = new Array(this.colCount).fill(null).map(() => []);
            }

            toggleTheme() {
                document.documentElement.classList.toggle('light');
            }

            toggleSidebar() {
                this.sidebarVisible = !this.sidebarVisible;
                document.getElementById('sidebar').classList.toggle('collapsed', !this.sidebarVisible);
                document.getElementById('sidebarToggle').textContent = this.sidebarVisible ? '‚óÄ' : '‚ñ∂';
            }

            toggleView(view) {
                this.currentView = view;
                document.querySelectorAll('.toolbar .btn').forEach(btn => btn.classList.remove('active'));
                document.getElementById(`btn-${view}`)?.classList.add('active');
                
                if (view === 'grid') {
                    this.render();
                } else if (view === 'gallery') {
                    this.renderGallery();
                } else if (view === 'kanban') {
                    this.renderKanban();
                }
            }

            toggleSourceView() {
                this.viewMode = this.viewMode === 'runtime' ? 'source' : 'runtime';
                const btn = document.getElementById('btn-source');
                const gridWrapper = document.getElementById('gridWrapper');

                if (this.viewMode === 'source') {
                    btn.classList.add('active');
                    gridWrapper.classList.add('source-view');
                    // Hide chart overlays in source view
                    this.chartOverlays.forEach(overlay => overlay.style.display = 'none');
                } else {
                    btn.classList.remove('active');
                    gridWrapper.classList.remove('source-view');
                    // Show chart overlays back
                    this.chartOverlays.forEach(overlay => overlay.style.display = '');
                }
                this.render();
                this.selectCell(this.selectedCell.row, this.selectedCell.col);
            }

            switchView(viewName) {
                document.querySelectorAll('.view-item').forEach(item => item.classList.remove('active'));
                event.target.closest('.view-item').classList.add('active');
                
                if (viewName === 'grouped') {
                    this.applyGrouping();
                } else {
                    this.groupByColumn = null;
                    this.render();
                }
            }

            renderGallery() {
                // Simplified gallery view
                const container = document.getElementById('gridWrapper');
                let html = '<div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); gap: 16px; padding: 16px;">';
                
                for (let row = 0; row < this.rowCount; row++) {
                    if (this.hiddenRows.has(row)) continue;
                    
                    html += `<div style="background: var(--bg-primary); border: 1px solid var(--border); border-radius: 8px; padding: 16px; box-shadow: var(--shadow-sm);">`;
                    html += `<div style="font-weight: 600; margin-bottom: 8px; color: var(--text-primary);">Record ${row + 1}</div>`;
                    
                    for (let col = 0; col < this.colCount; col++) {
                        const value = this.data[row][col];
                        if (value) {
                            html += `<div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 4px;">
                                <span style="font-weight: 500;">${this.headers[col]}:</span> ${value}
                            </div>`;
                        }
                    }
                    html += '</div>';
                }
                html += '</div>';
                container.innerHTML = html;
            }

            renderKanban() {
                // Find a status-like column or use first column
                let statusCol = this.fieldTypes.findIndex(type => type === 'select');
                if (statusCol === -1) statusCol = 0;
                
                const groups = {};
                for (let row = 0; row < this.rowCount; row++) {
                    const status = this.data[row][statusCol] || 'Uncategorized';
                    if (!groups[status]) groups[status] = [];
                    groups[status].push(row);
                }

                const container = document.getElementById('gridWrapper');
                let html = '<div style="display: flex; gap: 16px; padding: 16px; overflow-x: auto; height: 100%;">';
                
                for (const [status, rows] of Object.entries(groups)) {
                    html += `<div style="min-width: 280px; background: var(--bg-secondary); border-radius: 8px; padding: 12px;">
                        <div style="font-weight: 600; margin-bottom: 12px; padding: 8px; background: var(--bg-primary); border-radius: 6px; color: var(--text-primary);">
                            ${status} (${rows.length})
                        </div>`;
                    
                    for (const row of rows) {
                        html += `<div style="background: var(--bg-primary); border: 1px solid var(--border); border-radius: 6px; padding: 12px; margin-bottom: 8px; cursor: pointer;" onclick="spreadsheet.selectCell(${row}, 0)">`;
                        for (let col = 0; col < Math.min(3, this.colCount); col++) {
                            const value = this.data[row][col];
                            if (value) {
                                html += `<div style="font-size: 12px; margin-bottom: 4px; color: var(--text-primary);">${value}</div>`;
                            }
                        }
                        html += '</div>';
                    }
                    html += '</div>';
                }
                html += '</div>';
                container.innerHTML = html;
            }

            generateHeaders() {
                this.headers = [];
                for (let i = 0; i < this.colCount; i++) {
                    this.headers.push(this.numberToColumnName(i));
                }
            }

            numberToColumnName(num) {
                let result = '';
                num++;
                while (num > 0) {
                    num--;
                    result = String.fromCharCode(65 + (num % 26)) + result;
                    num = Math.floor(num / 26);
                }
                return result;
            }

            columnNameToNumber(name) {
                let result = 0;
                for (let i = 0; i < name.length; i++) {
                    result = result * 26 + (name.charCodeAt(i) - 64);
                }
                return result - 1;
            }

            initializeData() {
                this.data = [];
                this.formulas = [];
                for (let i = 0; i < this.rowCount; i++) {
                    this.data[i] = new Array(this.colCount).fill('');
                    this.formulas[i] = new Array(this.colCount).fill('');
                }
            }

            updateFilterOptions() {
                const filterColumn = document.getElementById('filterColumn');
                const groupBySelect = document.getElementById('groupBySelect');
                const sortColumn = document.getElementById('sortColumn');
                
                const options = this.headers.map((h, i) => `<option value="${i}">${h}</option>`).join('');
                
                filterColumn.innerHTML = '<option value="">Select column...</option>' + options;
                groupBySelect.innerHTML = '<option value="">None</option>' + options;
                sortColumn.innerHTML = '<option value="">Select column...</option>' + options;
            }

            applyGrouping() {
                const select = document.getElementById('groupBySelect');
                this.groupByColumn = select.value !== '' ? parseInt(select.value) : null;
                this.render();
            }

            addFilter() {
                const col = document.getElementById('filterColumn').value;
                const operator = document.getElementById('filterOperator').value;
                const value = document.getElementById('filterValue').value;
                
                if (col === '') return;
                
                this.filters.push({ col: parseInt(col), operator, value });
                this.applyFilters();
            }

            applyFilters() {
                this.hiddenRows.clear();
                
                for (let row = 0; row < this.rowCount; row++) {
                    let hide = false;
                    
                    for (const filter of this.filters) {
                        const cellValue = this.data[row][filter.col];
                        const cellStr = String(cellValue).toLowerCase();
                        const filterVal = filter.value.toLowerCase();
                        
                        switch (filter.operator) {
                            case 'equals':
                                if (cellStr !== filterVal) hide = true;
                                break;
                            case 'contains':
                                if (!cellStr.includes(filterVal)) hide = true;
                                break;
                            case 'greater':
                                if (parseFloat(cellValue) <= parseFloat(filter.value)) hide = true;
                                break;
                            case 'less':
                                if (parseFloat(cellValue) >= parseFloat(filter.value)) hide = true;
                                break;
                            case 'empty':
                                if (cellValue !== '') hide = true;
                                break;
                        }
                    }
                    
                    if (hide) this.hiddenRows.add(row);
                }
                
                this.render();
                this.updateRecordCount();
            }

            applySort() {
                const col = document.getElementById('sortColumn').value;
                const direction = document.getElementById('sortDirection').value;
                
                if (col === '') return;
                
                this.sortConfig = { column: parseInt(col), direction };
                
                // Create array of indices and sort
                const indices = Array.from({length: this.rowCount}, (_, i) => i);
                indices.sort((a, b) => {
                    const valA = this.data[a][this.sortConfig.column];
                    const valB = this.data[b][this.sortConfig.column];
                    
                    let comparison = 0;
                    if (valA < valB) comparison = -1;
                    if (valA > valB) comparison = 1;
                    
                    return this.sortConfig.direction === 'asc' ? comparison : -comparison;
                });
                
                // Reorder data
                const newData = indices.map(i => this.data[i]);
                const newFormulas = indices.map(i => this.formulas[i]);
                
                this.data = newData;
                this.formulas = newFormulas;
                
                this.render();
            }

            setFieldType() {
                const type = document.getElementById('fieldType').value;
                const { col } = this.selectedCell;
                this.fieldTypes[col] = type;
                
                if (type === 'select' || type === 'multiselect') {
                    const options = prompt('Enter options separated by commas:', 'Option 1, Option 2, Option 3');
                    if (options) {
                        this.selectOptions[col] = options.split(',').map(o => o.trim());
                    }
                } else if (type === 'link') {
                    this.openLinkedRecordModal();
                }
                
                this.render();
            }

            openLinkedRecordModal() {
                const modal = document.getElementById('linkedRecordModal');
                const list = document.getElementById('recordList');
                
                let html = '';
                for (let row = 0; row < this.rowCount; row++) {
                    const firstCell = this.data[row][0] || `Record ${row + 1}`;
                    html += `
                        <div class="record-item" data-row="${row}" onclick="this.classList.toggle('selected')">
                            <input type="checkbox" class="record-checkbox" onchange="event.stopPropagation()">
                            <div class="record-preview">
                                <div class="record-field">
                                    <div class="record-field-label">Primary Field</div>
                                    <div>${firstCell}</div>
                                </div>
                            </div>
                        </div>
                    `;
                }
                
                list.innerHTML = html;
                modal.classList.add('active');
            }

            closeLinkedRecordModal() {
                document.getElementById('linkedRecordModal').classList.remove('active');
            }

            confirmLinkRecords() {
                const selected = document.querySelectorAll('.record-item.selected');
                const { row, col } = this.selectedCell;
                
                const links = Array.from(selected).map(el => parseInt(el.dataset.row));
                this.linkedRecords[col] = links;
                
                this.data[row][col] = `${links.length} linked records`;
                this.closeLinkedRecordModal();
                this.render();
            }

            render() {
                if (this.currentView !== 'grid') {
                    this.toggleView('grid');
                    return;
                }

                const thead = document.getElementById('tableHead');
                const tbody = document.getElementById('tableBody');
                
                // Render headers
                let headerHTML = '<tr><th class="corner" onclick="spreadsheet.selectAll()"></th>';
                for (let col = 0; col < this.colCount; col++) {
                    const fieldType = this.fieldTypes[col];
                    const typeIcon = this.getFieldTypeIcon(fieldType);
                    headerHTML += `<th class="col-header" data-col="${col}" style="min-width: ${this.columnWidths[col]}px">
                        ${typeIcon} ${this.headers[col]}
                        <div class="resize-handle" data-col="${col}"></div>
                    </th>`;
                }
                headerHTML += '</tr>';
                thead.innerHTML = headerHTML;

                // Group data if needed
                let rowsToRender = [];
                if (this.groupByColumn !== null) {
                    const groups = {};
                    for (let row = 0; row < this.rowCount; row++) {
                        const key = this.data[row][this.groupByColumn] || '(Empty)';
                        if (!groups[key]) groups[key] = [];
                        groups[key].push(row);
                    }
                    
                    for (const [key, rows] of Object.entries(groups)) {
                        rowsToRender.push({ type: 'group', key, count: rows.length });
                        rows.forEach(row => rowsToRender.push({ type: 'row', index: row }));
                    }
                } else {
                    for (let row = 0; row < this.rowCount; row++) {
                        rowsToRender.push({ type: 'row', index: row });
                    }
                }

                // Render body
                let bodyHTML = '';
                let visibleRowCount = 0;
                
                for (const item of rowsToRender) {
                    if (item.type === 'group') {
                        bodyHTML += `<tr class="group-header" onclick="spreadsheet.toggleGroup('${item.key}')">
                            <th class="row-header"><span class="group-toggle">‚ñº</span></th>
                            <td colspan="${this.colCount}" style="text-align: left; padding-left: 12px;">
                                ${item.key} (${item.count})
                            </td>
                        </tr>`;
                    } else {
                        const row = item.index;
                        
                        if (this.hiddenRows.has(row)) continue;
                        visibleRowCount++;
                        
                        const groupClass = this.groupByColumn !== null ? 'grouped-row' : '';
                        bodyHTML += `<tr class="${groupClass}" data-row="${row}"><th class="row-header" data-row="${row}">${row + 1}</th>`;
                        
                        for (let col = 0; col < this.colCount; col++) {
                            const value = this.data[row][col];
                            const hasFormula = this.formulas[row][col] !== '';
                            const isEmpty = value === '' || value === undefined;
                            const fieldType = this.fieldTypes[col];
                            const isSourceView = this.viewMode === 'source';

                            let displayValue = value;
                            let cellClass = '';
                            let extraAttrs = '';

                            // Source view: show raw formulas
                            if (isSourceView && hasFormula) {
                                displayValue = this.escapeHtml(this.formulas[row][col]);
                                cellClass = 'cell-formula';
                            } else if (isSourceView) {
                                displayValue = this.escapeHtml(value);
                            // Check if this cell is a chart anchor
                            } else if (this._chartAnchors && this._chartAnchors.has(`${row},${col}`)) {
                                const chartType = this._chartAnchors.get(`${row},${col}`);
                                const icons = { pie: '\u{1F4CA}', bar: '\u{1F4CA}', line: '\u{1F4C8}', gauge: '\u{1F3AF}' };
                                cellClass = 'chart-anchor';
                                displayValue = icons[chartType] || '\u{1F4CA}';
                                extraAttrs = ` data-chart-icon=""`;
                            // Apply field type rendering (runtime mode)
                            } else if (fieldType === 'checkbox') {
                                cellClass = 'cell-checkbox';
                                displayValue = `<input type="checkbox" ${value ? 'checked' : ''} onclick="event.stopPropagation(); spreadsheet.toggleCheckbox(${row}, ${col})">`;
                            } else if (fieldType === 'select' && value) {
                                displayValue = `<span class="cell-select">${value}</span>`;
                            } else if (fieldType === 'link' && value) {
                                cellClass = 'cell-link';
                                displayValue = value;
                            } else if (!isNaN(value) && value !== '' && !hasFormula && fieldType === 'number') {
                                cellClass = 'cell-number';
                            } else if (hasFormula && value === '#ERROR') {
                                cellClass = 'cell-error';
                            }

                            const emptyClass = isEmpty && !cellClass.includes('chart-anchor') ? 'empty' : '';
                            const meta = this.columnMeta?.[col];
                            const alignStyle = meta?.align === 'right' ? 'text-align:right;justify-content:flex-end;'
                                : meta?.align === 'center' ? 'text-align:center;justify-content:center;' : '';

                            bodyHTML += `<td data-row="${row}" data-col="${col}" class="${cellClass} ${emptyClass}"${extraAttrs}>
                                <div class="cell-content" ${alignStyle ? `style="${alignStyle}"` : ''}>${isEmpty && !cellClass.includes('chart-anchor') ? '' : displayValue}</div>
                            </td>`;
                        }
                        bodyHTML += '</tr>';
                    }
                }
                tbody.innerHTML = bodyHTML;

                this.setupCellListeners();
                this.setupResizeHandles();
                this.updateRecordCount(visibleRowCount);
            }

            getFieldTypeIcon(type) {
                const icons = {
                    'text': 'T',
                    'longtext': '¬∂',
                    'number': '#',
                    'checkbox': '‚òê',
                    'select': '‚ñº',
                    'multiselect': '‚ò∞',
                    'date': 'üìÖ',
                    'attachment': 'üìé',
                    'link': 'üîó',
                    'formula': '∆í'
                };
                return `<span style="opacity: 0.5; margin-right: 4px;">${icons[type] || 'T'}</span>`;
            }

            toggleGroup(key) {
                // Simple toggle - in real implementation would track expanded state
                this.render();
            }

            toggleCheckbox(row, col) {
                this.data[row][col] = !this.data[row][col];
                this.recalculateAll();
                this.render();
            }

            setupCellListeners() {
                const cells = document.querySelectorAll('td:not(.group-header td)');
                cells.forEach(cell => {
                    cell.addEventListener('click', (e) => {
                        if (e.target.tagName === 'INPUT') return;
                        if (this.isEditing) {
                            this.commitEdit();
                        }
                        const row = parseInt(cell.dataset.row);
                        const col = parseInt(cell.dataset.col);
                        if (!isNaN(row) && !isNaN(col)) {
                            this.selectCell(row, col);
                        }
                    });

                    cell.addEventListener('dblclick', (e) => {
                        if (e.target.tagName === 'INPUT') return;
                        const row = parseInt(cell.dataset.row);
                        const col = parseInt(cell.dataset.col);
                        if (!isNaN(row) && !isNaN(col)) {
                            // In source view, switch back to runtime and select
                            if (this.viewMode === 'source') {
                                this.toggleSourceView();
                                this.selectCell(row, col);
                                return;
                            }
                            this.startEditing(row, col);
                        }
                    });
                });

                const rowHeaders = document.querySelectorAll('.row-header');
                rowHeaders.forEach(header => {
                    header.addEventListener('click', () => {
                        if (this.isEditing) this.commitEdit();
                        const row = parseInt(header.dataset.row);
                        if (!isNaN(row)) this.selectRow(row);
                    });
                });

                const colHeaders = document.querySelectorAll('.col-header');
                colHeaders.forEach(header => {
                    header.addEventListener('click', () => {
                        if (this.isEditing) this.commitEdit();
                        const col = parseInt(header.dataset.col);
                        this.selectColumn(col);
                    });
                });
            }

            setupResizeHandles() {
                const handles = document.querySelectorAll('.resize-handle');
                handles.forEach(handle => {
                    let isResizing = false;
                    let startX, startWidth, colIndex;

                    handle.addEventListener('mousedown', (e) => {
                        isResizing = true;
                        startX = e.clientX;
                        colIndex = parseInt(handle.dataset.col);
                        startWidth = this.columnWidths[colIndex];
                        e.preventDefault();
                        e.stopPropagation();
                    });

                    document.addEventListener('mousemove', (e) => {
                        if (!isResizing) return;
                        const diff = e.clientX - startX;
                        this.columnWidths[colIndex] = Math.max(50, startWidth + diff);
                        this.render();
                        this.selectCell(this.selectedCell.row, this.selectedCell.col);
                    });

                    document.addEventListener('mouseup', () => {
                        isResizing = false;
                    });
                });
            }

            setupEventListeners() {
                const formulaInput = document.getElementById('formulaInput');
                const formulaWrapper = document.getElementById('formulaWrapper');
                
                formulaInput.addEventListener('keydown', (e) => {
                    // Autocomplete navigation
                    if (this.acItems.length > 0) {
                        if (e.key === 'ArrowDown') { e.preventDefault(); this.navigateAutocomplete(1); return; }
                        if (e.key === 'ArrowUp')   { e.preventDefault(); this.navigateAutocomplete(-1); return; }
                        if (e.key === 'Tab' || (e.key === 'Enter' && this.acIndex >= 0)) {
                            e.preventDefault();
                            this.acceptAutocomplete(formulaInput, this.acIndex);
                            return;
                        }
                        if (e.key === 'Escape') { e.preventDefault(); this.hideAutocomplete(); return; }
                    }

                    if (e.key === 'Enter') {
                        e.preventDefault();
                        this.hideAutocomplete();
                        this.hideArgHint();
                        document.getElementById('formulaErrorHint').classList.remove('visible');
                        this.commitEdit();
                        this.moveSelection(1, 0);
                    } else if (e.key === 'Escape') {
                        e.preventDefault();
                        this.hideAutocomplete();
                        this.hideArgHint();
                        document.getElementById('formulaErrorHint').classList.remove('visible');
                        this.cancelEdit();
                    }
                });

                formulaInput.addEventListener('input', (e) => {
                    const value = formulaInput.value;
                    if (value.startsWith('=')) {
                        formulaWrapper.classList.add('has-formula');
                    } else {
                        formulaWrapper.classList.remove('has-formula');
                    }
                    // Autocomplete
                    this.showAutocomplete(formulaInput);
                    // Live preview (debounced)
                    clearTimeout(this._previewTimer);
                    this._previewTimer = setTimeout(() => this.showFormulaPreview(value), 100);
                });

                formulaInput.addEventListener('blur', () => {
                    // Delay to allow mousedown on autocomplete items
                    setTimeout(() => {
                        this.hideAutocomplete();
                        this.hideArgHint();
                        if (this.isEditing) {
                            this.commitEdit();
                        }
                    }, 150);
                });

                // Reposition chart overlays on scroll
                document.getElementById('gridWrapper')?.addEventListener('scroll', () => {
                    this.repositionChartOverlays();
                });

                document.addEventListener('keydown', (e) => {
                    if (this.isEditing) return;

                    if (e.ctrlKey || e.metaKey || e.altKey) return;
                    
                    if (e.key.startsWith('Arrow')) {
                        e.preventDefault();
                        const rowDelta = e.key === 'ArrowDown' ? 1 : e.key === 'ArrowUp' ? -1 : 0;
                        const colDelta = e.key === 'ArrowRight' ? 1 : e.key === 'ArrowLeft' ? -1 : 0;
                        this.moveSelection(rowDelta, colDelta);
                    } else if (e.key === 'Delete' || e.key === 'Backspace') {
                        e.preventDefault();
                        this.clearCell(this.selectedCell.row, this.selectedCell.col);
                    } else if (e.key.length === 1 && !e.ctrlKey && !e.metaKey) {
                        e.preventDefault();
                        this.startEditing(this.selectedCell.row, this.selectedCell.col, e.key);
                    }
                });
            }

            selectCell(row, col) {
                document.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
                
                this.selectedCell = { row, col };
                
                const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                const colHeader = document.querySelector(`th.col-header[data-col="${col}"]`);
                const rowHeader = document.querySelector(`th.row-header[data-row="${row}"]`);
                
                if (cell) cell.classList.add('selected');
                if (colHeader) colHeader.classList.add('selected');
                if (rowHeader) rowHeader.classList.add('selected');
                
                const cellRef = this.headers[col] + (row + 1);
                document.getElementById('cellRef').textContent = cellRef;
                
                const formulaInput = document.getElementById('formulaInput');
                const formulaWrapper = document.getElementById('formulaWrapper');
                const fieldTypeSelect = document.getElementById('fieldType');
                
                const formula = this.formulas[row][col];
                const value = this.data[row][col];
                
                const errorHint = document.getElementById('formulaErrorHint');
                if (formula) {
                    formulaInput.value = formula;
                    formulaWrapper.classList.add('has-formula');
                    fieldTypeSelect.value = 'formula';
                    if (value === '#ERROR') {
                        errorHint.textContent = 'Formula error ‚Äî check syntax and cell references';
                        errorHint.classList.add('visible');
                    } else {
                        errorHint.classList.remove('visible');
                    }
                } else {
                    formulaInput.value = value || '';
                    formulaWrapper.classList.remove('has-formula');
                    fieldTypeSelect.value = this.fieldTypes[col] || 'text';
                    errorHint.classList.remove('visible');
                }

                this.updateStatusBar();
            }

            selectRow(row) {
                document.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
                document.querySelectorAll(`td[data-row="${row}"]`).forEach(cell => cell.classList.add('selected'));
                document.querySelector(`th.row-header[data-row="${row}"]`).classList.add('selected');
            }

            selectColumn(col) {
                document.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
                document.querySelectorAll(`td[data-col="${col}"]`).forEach(cell => cell.classList.add('selected'));
                document.querySelector(`th.col-header[data-col="${col}"]`).classList.add('selected');
            }

            selectAll() {
                document.querySelectorAll('td').forEach(cell => cell.classList.add('selected'));
            }

            escapeHtml(str) {
                if (!str) return '';
                return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
            }

            moveSelection(rowDelta, colDelta) {
                const newRow = Math.max(0, Math.min(this.rowCount - 1, this.selectedCell.row + rowDelta));
                const newCol = Math.max(0, Math.min(this.colCount - 1, this.selectedCell.col + colDelta));
                this.selectCell(newRow, newCol);
            }

            startEditing(row, col, initialChar = null) {
                this.isEditing = true;
                this.editStartValue = initialChar || this.formulas[row][col] || this.data[row][col] || '';
                
                const formulaInput = document.getElementById('formulaInput');
                const formulaWrapper = document.getElementById('formulaWrapper');
                
                formulaInput.value = this.editStartValue;
                formulaInput.focus();
                
                if (initialChar) {
                    formulaInput.setSelectionRange(1, 1);
                } else {
                    formulaInput.select();
                }
                
                if (this.editStartValue.startsWith('=')) {
                    formulaWrapper.classList.add('has-formula');
                } else {
                    formulaWrapper.classList.remove('has-formula');
                }
            }

            commitEdit() {
                if (!this.isEditing) return;
                
                const { row, col } = this.selectedCell;
                const formulaInput = document.getElementById('formulaInput');
                const value = formulaInput.value;
                
                if (value.startsWith('=')) {
                    this.formulas[row][col] = value;
                    this.data[row][col] = this.evaluateFormula(value.substring(1), row, col);
                    this.fieldTypes[col] = 'formula';
                } else {
                    this.formulas[row][col] = '';
                    this.data[row][col] = value;
                }
                
                this.isEditing = false;
                this.editStartValue = '';
                
                this.recalculateAll();
                this.render();
                this.selectCell(row, col);
            }

            cancelEdit() {
                this.isEditing = false;
                this.editStartValue = '';
                this.selectCell(this.selectedCell.row, this.selectedCell.col);
            }

            clearCell(row, col) {
                this.data[row][col] = '';
                this.formulas[row][col] = '';
                this.recalculateAll();
                this.render();
                this.selectCell(row, col);
            }

            evaluateFormula(formula, currentRow, currentCol) {
                try {
                    let processedFormula = formula.trim();
                    
                    const functionNames = ['SUM', 'AVG', 'AVERAGE', 'MAX', 'MIN', 'COUNT', 'IF'];
                    processedFormula = processedFormula.replace(/([A-Za-z_][A-Za-z0-9_]*)\s*(\d+)/g, (match, header, rowNum) => {
                        if (functionNames.includes(header.toUpperCase())) return match;
                        const colIndex = this.headers.indexOf(header);
                        if (colIndex !== -1 && rowNum > 0 && rowNum <= this.rowCount) {
                            const value = this.data[rowNum - 1][colIndex];
                            if (value === '' || value === undefined) return '0';
                            return isNaN(value) ? `"${value}"` : value;
                        }
                        return '0';
                    });
                    
                    processedFormula = processedFormula.replace(/([A-Z]+)(\d+)(?::([A-Z]+)(\d+))?/g, (match, col, row, endCol, endRow) => {
                        if (endCol && endRow) {
                            return this.getRangeValue(col, parseInt(row), endCol, parseInt(endRow));
                        } else {
                            const colIndex = this.columnNameToNumber(col);
                            const rowIndex = parseInt(row) - 1;
                            if (rowIndex >= 0 && rowIndex < this.rowCount && colIndex >= 0 && colIndex < this.colCount) {
                                const value = this.data[rowIndex][colIndex];
                                if (value === '' || value === undefined) return '0';
                                return isNaN(value) ? `"${value}"` : value;
                            }
                            return '0';
                        }
                    });
                    
                    processedFormula = this.evaluateFunctions(processedFormula);
                    
                    const result = this.safeEval(processedFormula);
                    return isNaN(result) ? result : Math.round(result * 100000000) / 100000000;
                } catch (e) {
                    return '#ERROR';
                }
            }

            getRangeValue(startCol, startRow, endCol, endRow) {
                const startColIndex = this.columnNameToNumber(startCol);
                const endColIndex = this.columnNameToNumber(endCol);
                const startRowIndex = startRow - 1;
                const endRowIndex = endRow - 1;
                
                const values = [];
                for (let r = startRowIndex; r <= endRowIndex; r++) {
                    for (let c = startColIndex; c <= endColIndex; c++) {
                        if (r >= 0 && r < this.rowCount && c >= 0 && c < this.colCount) {
                            const val = parseFloat(this.data[r][c]);
                            if (!isNaN(val)) values.push(val);
                        }
                    }
                }
                return `[${values.join(',')}]`;
            }

            evaluateFunctions(formula) {
                formula = formula.replace(/SUM\(([^)]+)\)/gi, (match, range) => {
                    const values = this.parseRange(range);
                    return values.reduce((a, b) => a + b, 0);
                });
                
                formula = formula.replace(/AVG\(([^)]+)\)/gi, (match, range) => {
                    const values = this.parseRange(range);
                    return values.length ? values.reduce((a, b) => a + b, 0) / values.length : 0;
                });
                
                formula = formula.replace(/AVERAGE\(([^)]+)\)/gi, (match, range) => {
                    const values = this.parseRange(range);
                    return values.length ? values.reduce((a, b) => a + b, 0) / values.length : 0;
                });
                
                formula = formula.replace(/MAX\(([^)]+)\)/gi, (match, range) => {
                    const values = this.parseRange(range);
                    return values.length ? Math.max(...values) : 0;
                });
                
                formula = formula.replace(/MIN\(([^)]+)\)/gi, (match, range) => {
                    const values = this.parseRange(range);
                    return values.length ? Math.min(...values) : 0;
                });
                
                formula = formula.replace(/COUNT\(([^)]+)\)/gi, (match, range) => {
                    const values = this.parseRange(range);
                    return values.length;
                });
                
                formula = formula.replace(/IF\(([^,]+),([^,]+),([^)]+)\)/gi, (match, condition, trueVal, falseVal) => {
                    const cond = this.safeEval(condition);
                    return cond ? trueVal.trim() : falseVal.trim();
                });
                
                return formula;
            }

            parseRange(range) {
                if (range.startsWith('[') && range.endsWith(']')) {
                    const content = range.slice(1, -1);
                    if (!content) return [];
                    return content.split(',').filter(x => x !== '').map(Number);
                }
                
                const num = parseFloat(range);
                if (!isNaN(num)) return [num];
                
                return [];
            }

            safeEval(expression) {
                const sanitized = expression
                    .replace(/[^0-9+\-*/().,[\]<>!=\s&|]/g, '')
                    .replace(/&&/g, '&&')
                    .replace(/\|\|/g, '||');
                
                try {
                    return new Function('return ' + sanitized)();
                } catch (e) {
                    return '#ERROR';
                }
            }

            recalculateAll() {
                for (let row = 0; row < this.rowCount; row++) {
                    for (let col = 0; col < this.colCount; col++) {
                        if (this.formulas[row][col]) {
                            this.data[row][col] = this.evaluateFormula(this.formulas[row][col].substring(1), row, col);
                        }
                    }
                }
            }

            // --- Formula Autocomplete & Hints ---

            showAutocomplete(input) {
                const ac = document.getElementById('formulaAutocomplete');
                const val = input.value;
                if (!val.startsWith('=')) { this.hideAutocomplete(); return; }

                // Extract the current token at cursor
                const cursor = input.selectionStart;
                const textBeforeCursor = val.substring(1, cursor); // skip '='
                const tokenMatch = textBeforeCursor.match(/([A-Z]+)$/i);
                if (!tokenMatch) { this.hideAutocomplete(); this.showArgHint(val, cursor); return; }

                const token = tokenMatch[1].toUpperCase();
                this.acItems = this.formulaCatalog.filter(f => f.name.startsWith(token));
                if (this.acItems.length === 0) { this.hideAutocomplete(); return; }

                this.acIndex = 0;
                ac.innerHTML = this.acItems.map((f, i) =>
                    `<div class="formula-autocomplete-item${i === 0 ? ' active' : ''}" data-idx="${i}">` +
                    `<span class="fn-name">${f.name}</span>` +
                    `<span class="fn-syntax">${f.syntax}</span>` +
                    `<span class="fn-desc">${f.desc}</span></div>`
                ).join('');
                ac.classList.add('visible');

                // mousedown (not click) to avoid blur race
                ac.querySelectorAll('.formula-autocomplete-item').forEach(el => {
                    el.addEventListener('mousedown', (e) => {
                        e.preventDefault();
                        this.acceptAutocomplete(input, parseInt(el.dataset.idx));
                    });
                });
            }

            hideAutocomplete() {
                const ac = document.getElementById('formulaAutocomplete');
                ac.classList.remove('visible');
                ac.innerHTML = '';
                this.acItems = [];
                this.acIndex = -1;
            }

            navigateAutocomplete(delta) {
                if (this.acItems.length === 0) return;
                this.acIndex = Math.max(0, Math.min(this.acItems.length - 1, this.acIndex + delta));
                const ac = document.getElementById('formulaAutocomplete');
                ac.querySelectorAll('.formula-autocomplete-item').forEach((el, i) => {
                    el.classList.toggle('active', i === this.acIndex);
                });
                const activeEl = ac.querySelector('.active');
                if (activeEl) activeEl.scrollIntoView({ block: 'nearest' });
            }

            acceptAutocomplete(input, idx) {
                const fn = this.acItems[idx || this.acIndex];
                if (!fn) return;

                const cursor = input.selectionStart;
                const val = input.value;
                const textBeforeCursor = val.substring(0, cursor);
                const tokenMatch = textBeforeCursor.match(/([A-Z]+)$/i);
                const tokenStart = tokenMatch ? cursor - tokenMatch[1].length : cursor;

                const before = val.substring(0, tokenStart);
                const after = val.substring(cursor);
                input.value = before + fn.name + '(' + after;
                const newCursor = tokenStart + fn.name.length + 1;
                input.setSelectionRange(newCursor, newCursor);
                input.focus();

                this.hideAutocomplete();
                this.showArgHint(input.value, newCursor);
            }

            showArgHint(value, cursor) {
                const hint = document.getElementById('formulaArgHint');
                if (!value.startsWith('=')) { hint.classList.remove('visible'); return; }

                const text = value.substring(1, cursor);
                // Find innermost unclosed function: count parens backward
                let depth = 0;
                let fnEnd = -1;
                for (let i = text.length - 1; i >= 0; i--) {
                    if (text[i] === ')') depth++;
                    else if (text[i] === '(') {
                        if (depth === 0) { fnEnd = i; break; }
                        depth--;
                    }
                }
                if (fnEnd < 0) { hint.classList.remove('visible'); return; }

                const fnMatch = text.substring(0, fnEnd).match(/([A-Z]+)$/i);
                if (!fnMatch) { hint.classList.remove('visible'); return; }

                const fnName = fnMatch[1].toUpperCase();
                const entry = this.formulaCatalog.find(f => f.name === fnName);
                if (!entry) { hint.classList.remove('visible'); return; }

                hint.innerHTML = `<span class="hint-fn">${entry.syntax}</span><span class="hint-sep">‚Äî</span><span class="hint-desc">${entry.desc}</span>`;
                hint.classList.add('visible');
            }

            hideArgHint() {
                document.getElementById('formulaArgHint').classList.remove('visible');
            }

            // --- Live Preview ---

            showFormulaPreview(value) {
                const errorHint = document.getElementById('formulaErrorHint');
                const sumDisplay = document.getElementById('sumDisplay');

                if (!value.startsWith('=')) {
                    errorHint.classList.remove('visible');
                    return;
                }

                try {
                    const result = this.evaluateFormula(value.substring(1), this.selectedCell.row, this.selectedCell.col);
                    if (result === '#ERROR') {
                        sumDisplay.textContent = 'Preview: #ERROR';
                        errorHint.textContent = 'Formula error ‚Äî check syntax and cell references';
                        errorHint.classList.add('visible');
                    } else {
                        sumDisplay.textContent = `Preview: ${result}`;
                        errorHint.classList.remove('visible');
                    }
                } catch (e) {
                    sumDisplay.textContent = 'Preview: #ERROR';
                    errorHint.textContent = e.message || 'Formula error';
                    errorHint.classList.add('visible');
                }
            }

            updateStatusBar() {
                const { row, col } = this.selectedCell;
                const value = this.data[row][col];
                const formula = this.formulas[row][col];
                document.getElementById('cellCount').textContent = `Cell ${this.headers[col]}${row + 1}`;
                
                if (formula) {
                    document.getElementById('sumDisplay').textContent = `Formula Result: ${value}`;
                } else if (!isNaN(value) && value !== '') {
                    document.getElementById('sumDisplay').textContent = `Value: ${value}`;
                } else {
                    document.getElementById('sumDisplay').textContent = '';
                }
            }

            updateRecordCount(count) {
                const total = this.rowCount - this.hiddenRows.size;
                const visible = count !== undefined ? count : total;
                document.getElementById('recordCount').textContent = `${visible} of ${this.rowCount} records`;
            }

            // Public API methods
            newFile() {
                if (confirm('Create new spreadsheet? Unsaved changes will be lost.')) {
                    this.rowCount = 20;
                    this.colCount = 10;
                    this.filters = [];
                    this.hiddenRows.clear();
                    this.groupByColumn = null;
                    this.init();
                }
            }

            openImportModal() {
                document.getElementById('importModal').classList.add('active');
                document.getElementById('csvInput').focus();
            }

            closeImportModal() {
                document.getElementById('importModal').classList.remove('active');
            }

            importCSV() {
                const csv = document.getElementById('csvInput').value.trim();
                if (!csv) return;
                
                const lines = csv.split('\n');
                if (lines.length === 0) return;
                
                const parsed = lines.map(line => {
                    const result = [];
                    let current = '';
                    let inQuotes = false;
                    
                    for (let char of line) {
                        if (char === '"') {
                            inQuotes = !inQuotes;
                        } else if (char === ',' && !inQuotes) {
                            result.push(current.trim());
                            current = '';
                        } else {
                            current += char;
                        }
                    }
                    result.push(current.trim());
                    return result;
                });
                
                const maxCols = Math.max(...parsed.map(row => row.length));
                this.rowCount = parsed.length;
                this.colCount = maxCols;
                
                this.generateHeaders();
                this.initializeData();
                this.initializeFieldTypes();
                
                for (let row = 0; row < parsed.length; row++) {
                    for (let col = 0; col < parsed[row].length; col++) {
                        const value = parsed[row][col];
                        if (value.startsWith('=')) {
                            this.formulas[row][col] = value;
                            this.data[row][col] = this.evaluateFormula(value.substring(1), row, col);
                        } else {
                            this.data[row][col] = value;
                        }
                    }
                }
                
                this.columnWidths = new Array(this.colCount).fill(100);
                this.updateFilterOptions();
                this.closeImportModal();
                this.render();
                this.selectCell(0, 0);
            }

            exportCSV() {
                let csv = '';
                for (let row = 0; row < this.rowCount; row++) {
                    const rowData = [];
                    for (let col = 0; col < this.colCount; col++) {
                        const formula = this.formulas[row][col];
                        const value = this.data[row][col];
                        const cellValue = formula || value;
                        if (cellValue.includes(',') || cellValue.includes('"')) {
                            rowData.push('"' + cellValue.replace(/"/g, '""') + '"');
                        } else {
                            rowData.push(cellValue);
                        }
                    }
                    csv += rowData.join(',') + '\n';
                }
                
                const blob = new Blob([csv], { type: 'text/csv' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'spreadsheet.csv';
                a.click();
                window.URL.revokeObjectURL(url);
            }

            addRow() {
                this.rowCount++;
                this.data.push(new Array(this.colCount).fill(''));
                this.formulas.push(new Array(this.colCount).fill(''));
                this.render();
                this.selectCell(this.selectedCell.row, this.selectedCell.col);
            }

            addColumn() {
                this.colCount++;
                this.headers.push(this.numberToColumnName(this.colCount - 1));
                this.columnWidths.push(100);
                this.fieldTypes.push('text');
                this.selectOptions.push([]);
                this.linkedRecords.push([]);
                
                for (let row = 0; row < this.rowCount; row++) {
                    this.data[row].push('');
                    this.formulas[row].push('');
                }
                
                this.updateFilterOptions();
                this.render();
                this.selectCell(this.selectedCell.row, this.selectedCell.col);
            }

            deleteRow() {
                if (this.rowCount <= 1) return;
                const row = this.selectedCell.row;
                this.data.splice(row, 1);
                this.formulas.splice(row, 1);
                this.rowCount--;
                if (this.selectedCell.row >= this.rowCount) {
                    this.selectedCell.row = this.rowCount - 1;
                }
                this.recalculateAll();
                this.render();
                this.selectCell(this.selectedCell.row, this.selectedCell.col);
            }

            // --- Chart Overlay Management ---

            renderCharts(charts) {
                if (!charts || !charts.length) {
                    // Remove all existing overlays
                    this.chartOverlays.forEach(overlay => overlay.remove());
                    this.chartOverlays.clear();
                    this._chartAnchors = null;
                    return;
                }

                // Build chart anchor map for render()
                this._chartAnchors = new Map();
                const gridWrapper = document.getElementById('gridWrapper');

                // Track which cells still have charts
                const activeCells = new Set();

                for (const chart of charts) {
                    const cellRef = chart.cell;
                    activeCells.add(cellRef);

                    // Parse cell ref to row,col
                    const match = cellRef.match(/^([A-Za-z]+)(\d+)$/);
                    if (!match) continue;
                    const col = this.columnNameToNumber(match[1]);
                    const row = parseInt(match[2]) - 1;

                    this._chartAnchors.set(`${row},${col}`, chart.type);

                    // Sparkline: render inline, no overlay
                    if (chart.type === 'sparkline') {
                        this._renderSparklineInCell(row, col, chart.resolvedValues);
                        continue;
                    }

                    // Create or update overlay
                    let overlay = this.chartOverlays.get(cellRef);
                    if (overlay) {
                        // Update existing chart data
                        this._updateChartData(overlay, chart);
                    } else {
                        overlay = this._createChartOverlay(chart, row, col, gridWrapper);
                        this.chartOverlays.set(cellRef, overlay);
                    }

                    // Position relative to anchor cell
                    this._positionOverlay(overlay, row, col);

                    // Respect source view
                    if (this.viewMode === 'source') {
                        overlay.style.display = 'none';
                    }
                }

                // Remove overlays for cells that no longer have charts
                for (const [cellRef, overlay] of this.chartOverlays) {
                    if (!activeCells.has(cellRef)) {
                        overlay.remove();
                        this.chartOverlays.delete(cellRef);
                    }
                }
            }

            _createChartOverlay(chart, row, col, container) {
                const overlay = document.createElement('div');
                overlay.className = 'chart-overlay';
                overlay.dataset.cell = chart.cell;
                overlay.style.width = '260px';
                overlay.style.height = '200px';

                const titlebar = document.createElement('div');
                titlebar.className = 'chart-titlebar';
                titlebar.innerHTML = `<span class="chart-type-label">${chart.type.toUpperCase()} \u2014 ${chart.cell}</span>`;

                const closeBtn = document.createElement('button');
                closeBtn.className = 'chart-close';
                closeBtn.textContent = '\u00D7';
                closeBtn.onclick = () => {
                    // Delete the formula from the anchor cell
                    this.clearCell(row, col);
                };
                titlebar.appendChild(closeBtn);

                const body = document.createElement('div');
                body.className = 'chart-body';
                body.style.height = 'calc(100% - 28px)';

                const canvas = document.createElement('canvas');
                body.appendChild(canvas);

                const resizeHandle = document.createElement('div');
                resizeHandle.className = 'chart-resize';

                overlay.appendChild(titlebar);
                overlay.appendChild(body);
                overlay.appendChild(resizeHandle);
                container.appendChild(overlay);

                // Create Chart.js instance
                this._createChart(canvas, chart);

                // Make draggable
                this._makeDraggable(overlay, titlebar);

                // Make resizable
                this._makeResizable(overlay, resizeHandle, canvas, chart);

                return overlay;
            }

            _createChart(canvas, chart) {
                if (typeof Chart === 'undefined') return;

                const isDark = !document.documentElement.classList.contains('light');
                const textColor = isDark ? '#c9d1d9' : '#24292f';
                const gridColor = isDark ? 'rgba(48,54,61,0.5)' : 'rgba(208,215,222,0.5)';

                const palette = [
                    '#58a6ff', '#3fb950', '#d29922', '#f85149',
                    '#bc8cff', '#79c0ff', '#56d364', '#e3b341',
                    '#ff7b72', '#d2a8ff'
                ];

                const config = { responsive: true, maintainAspectRatio: false };

                let chartConfig;
                if (chart.type === 'pie') {
                    chartConfig = {
                        type: 'pie',
                        data: {
                            labels: chart.resolvedLabels || [],
                            datasets: [{
                                data: chart.resolvedValues || [],
                                backgroundColor: palette.slice(0, (chart.resolvedValues || []).length),
                                borderWidth: 1,
                                borderColor: isDark ? '#21262d' : '#ffffff',
                            }]
                        },
                        options: {
                            ...config,
                            plugins: {
                                legend: { position: 'right', labels: { color: textColor, font: { size: 10 } } }
                            }
                        }
                    };
                } else if (chart.type === 'bar') {
                    chartConfig = {
                        type: 'bar',
                        data: {
                            labels: chart.resolvedLabels || [],
                            datasets: [{
                                data: chart.resolvedValues || [],
                                backgroundColor: palette[0],
                                borderRadius: 3,
                            }]
                        },
                        options: {
                            ...config,
                            plugins: { legend: { display: false } },
                            scales: {
                                x: { ticks: { color: textColor, font: { size: 9 } }, grid: { color: gridColor } },
                                y: { ticks: { color: textColor, font: { size: 9 } }, grid: { color: gridColor } }
                            }
                        }
                    };
                } else if (chart.type === 'line') {
                    chartConfig = {
                        type: 'line',
                        data: {
                            labels: chart.resolvedLabels || chart.resolvedValues.map((_, i) => i + 1),
                            datasets: [{
                                data: chart.resolvedValues || [],
                                borderColor: palette[0],
                                backgroundColor: 'rgba(88,166,255,0.1)',
                                fill: true,
                                tension: 0.3,
                                pointRadius: 2,
                            }]
                        },
                        options: {
                            ...config,
                            plugins: { legend: { display: false } },
                            scales: {
                                x: { ticks: { color: textColor, font: { size: 9 } }, grid: { color: gridColor } },
                                y: { ticks: { color: textColor, font: { size: 9 } }, grid: { color: gridColor } }
                            }
                        }
                    };
                } else if (chart.type === 'gauge') {
                    // Gauge as a doughnut chart
                    const val = (chart.resolvedValues || [0])[0] || 0;
                    const min = chart.min || 0;
                    const max = chart.max || 100;
                    const pct = Math.max(0, Math.min(1, (val - min) / (max - min)));
                    chartConfig = {
                        type: 'doughnut',
                        data: {
                            datasets: [{
                                data: [pct * 100, (1 - pct) * 100],
                                backgroundColor: [palette[0], isDark ? '#21262d' : '#e1e4e8'],
                                borderWidth: 0,
                            }]
                        },
                        options: {
                            ...config,
                            circumference: 180,
                            rotation: -90,
                            cutout: '75%',
                            plugins: {
                                legend: { display: false },
                                tooltip: { enabled: false }
                            }
                        }
                    };
                }

                if (chartConfig) {
                    const ctx = canvas.getContext('2d');
                    canvas._chartInstance = new Chart(ctx, chartConfig);
                }
            }

            _updateChartData(overlay, chart) {
                const canvas = overlay.querySelector('canvas');
                if (!canvas || !canvas._chartInstance) return;

                const ci = canvas._chartInstance;
                if (chart.type === 'gauge') {
                    const val = (chart.resolvedValues || [0])[0] || 0;
                    const min = chart.min || 0;
                    const max = chart.max || 100;
                    const pct = Math.max(0, Math.min(1, (val - min) / (max - min)));
                    ci.data.datasets[0].data = [pct * 100, (1 - pct) * 100];
                } else {
                    if (chart.resolvedLabels) ci.data.labels = chart.resolvedLabels;
                    ci.data.datasets[0].data = chart.resolvedValues || [];
                }
                ci.update('none');
            }

            _positionOverlay(overlay, row, col) {
                const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                if (!cell) return;

                // If manually dragged, don't reposition
                if (overlay.dataset.dragged === 'true') return;

                const cellRect = cell.getBoundingClientRect();
                const wrapperRect = document.getElementById('gridWrapper').getBoundingClientRect();
                overlay.style.left = (cellRect.left - wrapperRect.left + cellRect.width + 4) + 'px';
                overlay.style.top = (cellRect.top - wrapperRect.top) + 'px';
            }

            _renderSparklineInCell(row, col, values) {
                // Defer to after render completes
                requestAnimationFrame(() => {
                    const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                    if (!cell) return;

                    const content = cell.querySelector('.cell-content');
                    if (!content || !values || !values.length) return;

                    const min = Math.min(...values);
                    const max = Math.max(...values);
                    const range = max - min || 1;
                    const w = 80;
                    const h = 20;
                    const step = w / (values.length - 1 || 1);

                    const points = values.map((v, i) => {
                        const x = i * step;
                        const y = h - ((v - min) / range) * (h - 4) - 2;
                        return `${x},${y}`;
                    }).join(' ');

                    const isDark = !document.documentElement.classList.contains('light');
                    const color = isDark ? '#58a6ff' : '#0969da';

                    content.innerHTML = `<div class="sparkline-container">
                        <svg viewBox="0 0 ${w} ${h}" preserveAspectRatio="none">
                            <polyline points="${points}" fill="none" stroke="${color}" stroke-width="1.5" stroke-linejoin="round" stroke-linecap="round"/>
                        </svg>
                    </div>`;
                });
            }

            _makeDraggable(overlay, handle) {
                let startX, startY, startLeft, startTop;
                handle.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    startX = e.clientX;
                    startY = e.clientY;
                    startLeft = parseInt(overlay.style.left) || 0;
                    startTop = parseInt(overlay.style.top) || 0;
                    overlay.dataset.dragged = 'true';

                    const move = (e) => {
                        overlay.style.left = (startLeft + e.clientX - startX) + 'px';
                        overlay.style.top = (startTop + e.clientY - startY) + 'px';
                    };
                    const up = () => {
                        document.removeEventListener('mousemove', move);
                        document.removeEventListener('mouseup', up);
                    };
                    document.addEventListener('mousemove', move);
                    document.addEventListener('mouseup', up);
                });
            }

            _makeResizable(overlay, handle, canvas, chart) {
                let startX, startY, startW, startH;
                handle.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    startX = e.clientX;
                    startY = e.clientY;
                    startW = overlay.offsetWidth;
                    startH = overlay.offsetHeight;

                    const move = (e) => {
                        overlay.style.width = Math.max(200, startW + e.clientX - startX) + 'px';
                        overlay.style.height = Math.max(150, startH + e.clientY - startY) + 'px';
                        if (canvas._chartInstance) canvas._chartInstance.resize();
                    };
                    const up = () => {
                        document.removeEventListener('mousemove', move);
                        document.removeEventListener('mouseup', up);
                    };
                    document.addEventListener('mousemove', move);
                    document.addEventListener('mouseup', up);
                });
            }

            repositionChartOverlays() {
                for (const [cellRef, overlay] of this.chartOverlays) {
                    if (overlay.dataset.dragged === 'true') continue;
                    const match = cellRef.match(/^([A-Za-z]+)(\d+)$/);
                    if (!match) continue;
                    const col = this.columnNameToNumber(match[1]);
                    const row = parseInt(match[2]) - 1;
                    this._positionOverlay(overlay, row, col);
                }
            }

            deleteColumn() {
                if (this.colCount <= 1) return;
                const col = this.selectedCell.col;
                this.headers.splice(col, 1);
                this.columnWidths.splice(col, 1);
                this.fieldTypes.splice(col, 1);
                this.selectOptions.splice(col, 1);
                this.linkedRecords.splice(col, 1);
                
                for (let row = 0; row < this.rowCount; row++) {
                    this.data[row].splice(col, 1);
                    this.formulas[row].splice(col, 1);
                }
                
                this.colCount--;
                if (this.selectedCell.col >= this.colCount) {
                    this.selectedCell.col = this.colCount - 1;
                }
                
                this.updateFilterOptions();
                this.recalculateAll();
                this.render();
                this.selectCell(this.selectedCell.row, this.selectedCell.col);
            }
        }

        const spreadsheet = new SpreadsheetEngine();
        
        // Setup MCP Bridge + theme listener
        function setupPhotonBridge() {
            if (!window.photon) {
                setTimeout(setupPhotonBridge, 100);
                return;
            }
            initMCPBridge(spreadsheet);
            if (window.photon.onThemeChange) {
                window.photon.onThemeChange((theme) => {
                    if (theme === 'light') {
                        document.documentElement.classList.add('light');
                    } else {
                        document.documentElement.classList.remove('light');
                    }
                });
            }
        }
        document.addEventListener('DOMContentLoaded', setupPhotonBridge);
    </script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.7/dist/chart.umd.min.js"></script>
    <script src="mcp-bridge.js"></script>
</body>
</html>